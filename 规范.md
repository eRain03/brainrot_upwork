为了测试你提供的认证代码并验证它是否能成功调用 Eldorado.gg 的 API，我们需要编写一个完整的 Python 脚本。

这个脚本将执行两个步骤：

1. **身份验证**：使用你的账号和密码获取动态的 `IdToken`。
2. **API 测试**：带上 Token 和官方分配给你的 **Bot ID** 请求订单接口。

### 测试脚本 (test_eldorado_api.py)

请确保你已经安装了必要的库：`pip install boto3 pycognito requests`。

```python
import boto3
import requests
import json
from pycognito import AWSSRP
from botocore.exceptions import ClientError

# --- 官方认证参数 ---
_POOL_ID = 'us-east-2_M1nzCFgHk'
_CLIENT_ID = '1956req5ro9drdtbf5i6kis4la'
_REGION = 'us-east-2'

# --- 你的机器人 ID ---
MY_BOT_ID = "WxrldzSells-Bot-JyB1dZheIJ"

def get_eldorado_token(email, password):
    """
    使用 SRP 协议获取 IdToken
    """
    client = boto3.client('cognito-idp', region_name=_REGION)
    
    aws_srp = AWSSRP(
        username=email,
        password=password,
        pool_id=_POOL_ID,
        client_id=_CLIENT_ID,
        client=client
    )
    
    try:
        # 发起初始认证
        auth_params = aws_srp.get_auth_params()
        response = client.initiate_auth(
            AuthFlow='USER_SRP_AUTH',
            AuthParameters=auth_params,
            ClientId=_CLIENT_ID
        )
        
        # 处理密码挑战响应
        if response.get("ChallengeName") == "PASSWORD_VERIFIER":
            challenge_res = aws_srp.process_challenge(
                response["ChallengeParameters"], 
                auth_params
            )
            
            # 获取最终结果
            tokens = client.respond_to_auth_challenge(
                ClientId=_CLIENT_ID,
                ChallengeName="PASSWORD_VERIFIER",
                ChallengeResponses=challenge_res
            )
            
            return tokens['AuthenticationResult']['IdToken']
            
    except ClientError as e:
        print(f"认证失败: {e.response['Error']['Message']}")
        return None
    except Exception as e:
        print(f"发生未知错误: {e}")
        return None

def test_fetch_orders(id_token):
    """
    使用获取到的 Token 和 Bot ID 测试订单接口
    """
    # 根据之前的错误回显，此端点需要特定 Header
    url = "https://api.eldorado.io/api/v1/seller/orders"
    
    headers = {
        "Authorization": f"Bearer {id_token}",
        "X-Client-ID": MY_BOT_ID,       # 官方分配的 ID
        "X-Referral-ID": "bot",         # 400 错误提示要求的字段
        "Content-Type": "application/json"
    }

    print(f"\n[测试] 正在请求订单接口...")
    try:
        response = requests.get(url, headers=headers, timeout=10)
        
        print(f"状态码: {response.status_code}")
        
        if response.status_code == 200:
            print("✅ 成功连通 API！")
            print("订单数据:", json.dumps(response.json(), indent=2, ensure_ascii=False))
        elif response.status_code == 403:
            print("❌ 权限拒绝 (403): 请确认账号是否已获得卖家 API 授权（通常需 50 笔销售记录）")
            print("详细回显:", response.text)
        else:
            print(f"❌ 请求失败: {response.text}")
            
    except Exception as e:
        print(f"网络请求发生异常: {e}")

if __name__ == "__main__":
    print("=== Eldorado.gg 机器人集成测试 ===")
    
    # 建议使用拿到过官方 Bot ID 授权的原始邮箱
    email = input("请输入 Eldorado 账号 (Email): ").strip()
    password = input("请输入 Eldorado 密码: ").strip()

    token = get_eldorado_token(email, password)

    if token:
        print("✅ 身份验证成功，已获得 IdToken。")
        test_fetch_orders(token)
    else:
        print("❌ 无法继续测试，请检查登录信息。")

```

### 脚本说明与关键细节

1. **Headers 组合**：该脚本不仅使用了 `Authorization` (JWT Token)，还根据你之前遇到的 **400 错误** 补全了 `X-Client-ID` 和 `X-Referral-ID`。这是确保请求不被拒绝的关键。
2. **错误捕获**：如果返回 **403 Forbidden**，请结合 Body 中的 `message` 查看是否是由于“销售记录不足 50 笔”导致的权限限制。
3. **账号限制**：官方明确指出必须使用 **“邮箱 + 密码”** 登录方式。请确保你输入的账号已经在官网激活，且没有开启 MFA 二步验证（因为脚本暂未处理 MFA 挑战）。
